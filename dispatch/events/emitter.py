
import functools
import sys

from event import EventData, EventException, EventDeferred


class Emitter(object):
    def on(self, event, callback=None):
        """Hook to an event

        Parameters
        ----------
        event : str
            Event to attach to
        callback : func(EventData)
            Callback to call when event is fired. If not specified, this is
            used as a decorator

        Returns
        -------
        wrapper : func
            A decorator if callback is not set

        Examples
        --------
        >>> emitter = Emitter()
        >>> def my_func1(evt):
                print('Event called me!')
        >>> emitter.on('some_event', my_func1)
        >>> @emitter.on('some_event')
            def my_func2(evt):
                print('Event called me too!')
        >>> emitter.fire('some_event')
        Event called me!
        Event called me too!

        """
        try:
            self.event_handlers[event]
        except AttributeError:
            self.event_handlers = {event: []}
        except KeyError:
            self.event_handlers[event] = []

        if callback is None:
            def wrapper(func):
                self.event_handlers[event].append(func)
                return func
            return wrapper
        else:
            self.event_handlers[event].append(callback)

    def off(self, event, callback):
        """Remove callback from an event

        Parameters
        ----------
        event : str
            Event to remove from
        callback : func(EventData)
            Callback to be removed from this event. Only the first instance
            is removed

        Raises
        ------
        ValueError
            If the callback is not attached to this event
        """
        try:
            self.event_handlers[event].remove(callback)
        except (AttributeError, KeyError):
            raise ValueError('Callback not found')

    def once(self, event, callback=None):
        """Hook to an event once.

        Parameters
        ----------
        event : str
            Event to attach to
        callback : func(EventData)
            Callback to call when event is fired. If not specified, this is
            used as a decorator

        Returns
        -------
        wrapper : func
            A decorator if callback is not set
        """

        if callback is None:
            def wrapper(func):
                @functools.wraps(func)
                def call_once(*args, **kwargs):
                    ret = func(*args, **kwargs)
                    self.off(event, call_once)
                    return ret
                self.on(event, call_once)
                return func
            return wrapper
        else:
            @functools.wraps(callback)
            def call_once(*args, **kwargs):
                ret = callback(*args, **kwargs)
                self.off(event, call_once)
                return ret
            self.on(event, call_once)

    def all_off(self):
        """Remove all events"""
        try:
            del self.event_handlers
        except AttributeError:
            pass

    def fire(self, event, data=None, cancellable=True, catch_errors=True,
             late_throw=True):
        """Fires an event

        Parameters
        ----------
        event : str
            Event to fire
        data : object
            Data passed to the event
        cancellable : bool
            If True (default), callbacks can be stopped by calling evt.cancel()
        catch_errors : bool
            If True (default), callbacks will all be called even if there
            is an exception thrown
        late_throw : bool
            If True (default), this function will raise the first exception
            thrown

        Returns
        -------
        evt : EventData
            The passed event.

        Raises
        ------
        err : Exception
            If catch_errors is False, this raises the error that is
            generated by callback()

        See Also
        --------
        event.EventData
        """
        evt = EventData(event, self, data, cancellable)
        try:
            callbacks = self.event_handlers[event]
        except (KeyError, AttributeError):
            pass
        else:
            deferred_callbacks = []

            def process_callbacks(callbacks):
                for callback in callbacks[:]:
                    if evt.cancelled:
                        return evt
                    try:
                        callback(evt)
                    except EventDeferred:
                        deferred_callbacks.append(callback)
                    except Exception as err:
                        if catch_errors:
                            evt.add_error(sys.exc_info())
                        else:
                            raise err
            process_callbacks(callbacks)
            if deferred_callbacks:
                evt.deferred = True
                process_callbacks(deferred_callbacks)
        if late_throw and evt.errors:
            raise evt.errors[0][1], None, evt.errors[0][2]
        return evt
